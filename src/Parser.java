/*
* Pontifical Catholic University of Minas Gerais
* Institue of Exact Sciences and Technology
* Compilers
*
* Authors: Cleber Oliveira, Karen Martins, and Sarah Almeida
* IDs: 486564, 476140, 476181
 */

import java.io.BufferedReader;
import java.util.Stack;

/**
 * Processes the tokens generated by the lexical analyzer in order to verify if
 * the source program is generated by the grammar
 */
public class Parser {

    BufferedReader file;
    LexicalAnalyzer lexical;
    SymbolTable table;
    Symbol s;
    Memory m;
    Label l;
    Buffer b;
    Stack<String> aux = new Stack<>();

    /**
     * Default constructor, it initializes the variables that will be used
     * during its execution, creates the instance of the SymbolTable and
     * LexicalAnalyzer
     *
     * @param source BufferedReader containing the information of the source
     * file.
     */
    public Parser(BufferedReader source) {
        try {
            file = source;
            table = new SymbolTable();
            lexical = new LexicalAnalyzer(table);
            s = lexical.getNextLexeme(file);
            m = new Memory();
            l = new Label();
            b = new Buffer();
        } catch (Exception e) {
            System.err.println(e.getMessage());
        }
    }

    /**
     * Procedure that implements the initial symbol of the grammar.
     */
    public void S() {
        // semantic action [C0]
        b.add("sseg SEGMENT STACK        ;início seg. pilha");
        b.add("byte 16384 DUP(?)         ;dimensiona pilha");
        b.add("sseg ENDS                 ;fim seg. pilha");
        b.add("dseg SEGMENT PUBLIC 	;início seg. Dados");
        b.add("byte 16384 DUP(?)         ;temporários");
        b.add("");
        
        // S -> {D}
        while (s.getToken() == SymbolTable.INT || s.getToken() == SymbolTable.BOOLEAN || s.getToken() == SymbolTable.BYTE || s.getToken() == SymbolTable.STRING || s.getToken() == SymbolTable.FINAL) {
            D();
        }

        if (s.getToken() == SymbolTable.EOF) {
            System.err.println(lexical.line + ":fim de arquivo nao esperado.");
            System.exit(0);
        }
        
        // semantic action [C1]
        b.add("");
        b.add("dseg ENDS                 ;fim seg. dados");
        b.add("");
        b.add("cseg SEGMENT PUBLIC 	;início seg. Código");
        b.add("ASSUME CS:cseg, DS:dseg");
        b.add("_strt:                     ;início do programa");
        b.add("mov AX, dseg");
        b.add("mov DS, AX");
        
        while(!aux.empty()) {
            String value = aux.pop();
            String address = aux.pop();
            
            b.add("mov AX, " + value);
            b.add("mov DS:[" + address + "], AX");
        }

        // S -> {C}+
        do {
            C();
        } while (s.getToken() == SymbolTable.ID || s.getToken() == SymbolTable.WHILE || s.getToken() == SymbolTable.IF || s.getToken() == SymbolTable.SEMICOLON || s.getToken() == SymbolTable.READLN || s.getToken() == SymbolTable.WRITE || s.getToken() == SymbolTable.WRITELN);
        if (!lexical.EOF) {
            System.err.println(lexical.line + ":token nao esperado [" + s.getLexeme() + "].");
            System.exit(0);
        }
        
        // semantic action [C2]
        b.add("mov AH, 76");
        b.add("int 33");
        b.add("cseg ENDS                 ;fim seg. código");
        b.add("END _strt                  ;fim programa");
        
        b.print("c:/8086/c.asm");
    }

    /**
     * Procedure that implements the declarations.
     */
    private void D() {
        Symbol _Did = new Symbol("", Byte.MAX_VALUE);
        Symbol _Dconst = new Symbol("", Byte.MAX_VALUE);
        AuxiliarySymbol _D = new AuxiliarySymbol();
        boolean _Dminus, _Dinitialized;

        // D -> (INT|BOOLEAN|BYTE|STRING) ID [RECEIVE [MINUS] CONST] {COMMA ID [RECEIVE [MINUS] CONST]} SEMICOLON
        if (s.getToken() == SymbolTable.INT || s.getToken() == SymbolTable.BOOLEAN || s.getToken() == SymbolTable.BYTE || s.getToken() == SymbolTable.STRING) {
            
            // semantic action [T1]
            if (s.getToken() == SymbolTable.INT) {
                _D.setType(Symbol.TYPE_INTEGER);
            } 
            // semantic action [T2]
            else if (s.getToken() == SymbolTable.BOOLEAN) {
                _D.setType(Symbol.TYPE_LOGICAL);
            }
            // semantic action [T3]
            else if (s.getToken() == SymbolTable.BYTE) {
                _D.setType(Symbol.TYPE_BYTE);
            }
            // semantic action [T1]
            else {
                _D.setType(Symbol.TYPE_STRING);
            }
                
            matchToken(s.getToken());
            _Did = s;
            matchToken(SymbolTable.ID);
            
            // semantic action [U1]
            if (_Did.getCategory() == Symbol.NO_CATEGORY) {
                table.searchSymbol(_Did.getLexeme()).setCategory(Symbol.CATEGORY_VARIABLE);
            } else {
                System.err.println(lexical.line + ":identificador ja declarado [" + _Did.getLexeme() + "].");
                System.exit(0);
            }
            
            // semantic action [T5]
            table.searchSymbol(_Did.getLexeme()).setType(_D.getType());
            
            // semantic action [H1]
            _Dminus = false;
            
            // semantic action [H24]
            _Dinitialized = false;

            if (s.getToken() == SymbolTable.RECEIVE) {
                matchToken(SymbolTable.RECEIVE);

                if (s.getToken() == SymbolTable.MINUS) {
                    matchToken(SymbolTable.MINUS);
                    
                    // semantic action [T6]
                    if (_D.getType() != Symbol.TYPE_INTEGER) {
                        System.err.println(lexical.line + ":tipos incompativeis.");
                        System.exit(0);
                    } 
                    
                    // semantic action [H2]
                    _Dminus = true;
                }

                _Dconst = s;
                matchToken(SymbolTable.CONST);
                
                // semantic action [H25]
                _Dinitialized = true;
                
                // semantic action [T7]
                if ((_D.getType() != _Dconst.getType()) && (_D.getType() != Symbol.TYPE_INTEGER || _Dconst.getType() != Symbol.TYPE_BYTE)) {
                    System.err.println(lexical.line + ":tipos incompativeis.");
                    System.exit(0);
                } 
            }
            
            // semantic action [C3]
            if (_Dinitialized) {
                if (_D.getType() == Symbol.TYPE_INTEGER) {
                    table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateInteger());
                    
                    if (_Dminus) {
                        b.add("sword ? ;var. int");
                        aux.push("" + table.searchSymbol(_Did.getLexeme()).getAddress());
                        aux.push("-" + _Dconst.getLexeme());
                    } else {
                        b.add("sword " + _Dconst.getLexeme() + " ;var. int");
                    }
                } else if (_D.getType() == Symbol.TYPE_LOGICAL) {
                    table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateLogical());

                    if (_Did.getLexeme().equals("TRUE")) {
                        b.add("byte 255                ;var. boolean");
                    } else {
                        b.add("byte 0                 ;var. boolean");
                    }
                } else if (_D.getType() == Symbol.TYPE_BYTE) {
                   table.searchSymbol(_Did.getLexeme()).setAddress( m.allocateByte());
                    b.add("byte " + _Dconst.getLexeme() +  " ;var. boolean");
                } else {
                    table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateString());
                    int emptySize = 256 - _Dconst.getLexeme().length();
                    b.add("byte \"" + _Dconst.getLexeme() + "\" 	;var. string");
                    b.add("byte " + emptySize + " DUP(?) 	;var. string");
                }             
            } else {
                if (_D.getType() == Symbol.TYPE_INTEGER) {
                    table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateInteger());
                    b.add("sword ?               ;var. int");
                } else if (_D.getType() == Symbol.TYPE_LOGICAL) {
                    table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateLogical());
                    b.add("byte ?                ;var. boolean");
                } else if (_D.getType() == Symbol.TYPE_BYTE) {
                    table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateByte());
                    b.add("byte ?                ;var. boolean");
                } else {
                    table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateString());
                    b.add("byte 100 DUP(?) 	;var. string");
                }
            }  

            while (s.getToken() == SymbolTable.COMMA) {
                matchToken(SymbolTable.COMMA);
                _Did = s;
                matchToken(SymbolTable.ID);
                
                // semantic action [U1]
                if (_Did.getCategory() == Symbol.NO_CATEGORY) {
                    table.searchSymbol(_Did.getLexeme()).setCategory(Symbol.CATEGORY_VARIABLE);
                } else {
                    System.err.println(lexical.line + ":identificador ja declarado [" + _Did.getLexeme() + "].");
                    System.exit(0);
                }
                
                // semantic action [T5]
                table.searchSymbol(_Did.getLexeme()).setType(_D.getType());

                // semantic action [H1]
                _Dminus = false;

                // semantic action [H24]
                _Dinitialized = false;

                if (s.getToken() == SymbolTable.RECEIVE) {
                    matchToken(SymbolTable.RECEIVE);

                    if (s.getToken() == SymbolTable.MINUS) {
                        matchToken(SymbolTable.MINUS);
                        
                        // semantic action [T6]
                        if (_D.getType() != Symbol.TYPE_INTEGER) {
                            System.err.println(lexical.line + ":tipos incompativeis.");
                            System.exit(0);
                        } 

                        // semantic action [H2]
                        _Dminus = true;
                    }

                    _Dconst = s;
                    matchToken(SymbolTable.CONST);
                    
                    // semantic action [H25]
                    _Dinitialized = true;

                    // semantic action [T7]
                    if ((_D.getType() != _Dconst.getType()) && (_D.getType() != Symbol.TYPE_INTEGER || _Dconst.getType() != Symbol.TYPE_BYTE)) {
                        System.err.println(lexical.line + ":tipos incompativeis.");
                        System.exit(0);
                    } 
                }
                
                // semantic action [C3]
                if (_Dinitialized) {
                    if (_D.getType() == Symbol.TYPE_INTEGER) {
                        table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateInteger());
                        b.add("sword " + _Dconst.getLexeme() + " ;var. int");
                    } else if (_D.getType() == Symbol.TYPE_LOGICAL) {
                        table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateLogical());

                        if (_Did.getLexeme().equals("TRUE")) {
                            b.add("byte 255                ;var. boolean");
                        } else {
                            b.add("byte 0                 ;var. boolean");
                        }
                    } else if (_D.getType() == Symbol.TYPE_BYTE) {
                        table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateByte());
                        b.add("byte " + _Dconst.getLexeme() +  ";var. boolean");
                    } else {
                        table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateString());
                        int emptySize = 256 - _Dconst.getLexeme().length();
                        b.add("byte \"" + _Dconst.getLexeme() + "\" 	;var. string");
                        b.add("byte " + emptySize + " DUP(?)         ;var. string");
                    }             
                } else {
                    if (_D.getType() == Symbol.TYPE_INTEGER) {
                        table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateInteger());
                        b.add("sword ?               ;var. int");
                    } else if (_D.getType() == Symbol.TYPE_LOGICAL) {
                        table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateLogical());
                        b.add("byte ?                ;var. boolean");
                    } else if (_D.getType() == Symbol.TYPE_BYTE) {
                        table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateByte());
                        b.add("byte ?                ;var. boolean");
                    } else {
                        table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateString());
                        b.add("byte 256 DUP(?) 	;var. string");
                    }
                }       
            }

            matchToken(SymbolTable.SEMICOLON);
        } // D -> FINAL ID RECEIVE [MINUS] CONST SEMICOLON
        else {
            matchToken(SymbolTable.FINAL);
            _Did = s;
            matchToken(SymbolTable.ID);
            
            // semantic action [U2]
            if (_Did.getCategory() == Symbol.NO_CATEGORY) {
                table.searchSymbol(_Did.getLexeme()).setCategory(Symbol.CATEGORY_CONSTANT);
            } else {
                System.err.println(lexical.line + ":identificador ja declarado [" + _Did.getLexeme() + "].");
                System.exit(0);
            }
            
            // semantic action [H1]
            _Dminus = false;
            
            matchToken(SymbolTable.RECEIVE);

            if (s.getToken() == SymbolTable.MINUS) {
                matchToken(SymbolTable.MINUS);

                // semantic action [H2]
                _Dminus = true;
            }

            _Dconst = s;
            matchToken(SymbolTable.CONST);
            
            // semantic action [T8]
            if (_Dminus && _Dconst.getType() != Symbol.TYPE_INTEGER) {
                System.err.println(lexical.line + ":tipos incompativeis.");
                System.exit(0);
            } else {
                table.searchSymbol(_Did.getLexeme()).setType(_Dconst.getType());
                _D.setType(_Dconst.getType());
            }
            
            // semantic action [C4]
            if (_D.getType() == Symbol.TYPE_INTEGER) {
                table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateInteger());
                
                if (_Dminus) {
                    b.add("sword -" + _Dconst.getLexeme() + " ;var. int");
                } else {
                    b.add("sword " + _Dconst.getLexeme() + " ;var. int");
                }
            } else if (_D.getType() == Symbol.TYPE_LOGICAL) {
                table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateLogical());
                
                if (_Did.getLexeme().equals("TRUE")) {
                    b.add("byte 255                ;var. boolean");
                } else {
                    b.add("byte 0                 ;var. boolean");
                }
            } else if (_D.getType() == Symbol.TYPE_BYTE) {
                table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateByte());
                b.add("byte " + _Dconst.getLexeme() +  " ;var. boolean");
            } else {
                table.searchSymbol(_Did.getLexeme()).setAddress(m.allocateString(_Dconst.getLexeme().length()));
                b.add("byte \"" + _Dconst.getLexeme() + "\" 	;var. string");
            }
            
            matchToken(SymbolTable.SEMICOLON);
        }
    }

    /**
     * Procedure that implements the commands.
     */
    private void C() {
        AuxiliarySymbol _C = new AuxiliarySymbol();
        Symbol _Cid;
        boolean _ClineBreak, _Celse;
        
        // C -> ID RECEIVE E SEMICOLON
        if (s.getToken() == SymbolTable.ID) {
            _Cid = s;
            matchToken(SymbolTable.ID);
            b.add("");
            b.add(";a");
            
            // semantic action [U3]
            if (_Cid.getCategory() == Symbol.NO_CATEGORY) {
                System.err.println(lexical.line + ":identificador nao declarado [" + _Cid.getLexeme() + "].");
                System.exit(0);
            } 
            
            // semantic action [L1]
            if (_Cid.getCategory() != Symbol.CATEGORY_VARIABLE) {
                System.err.println(lexical.line + ":classe de identificador incompativel [" + _Cid.getLexeme() + "].");
                System.exit(0);
            }
            
            matchToken(SymbolTable.RECEIVE);
            m.resetTemporary();
            E(_C);
            
            // semantic action [T9]
            if ((_Cid.getType() != _C.getType()) && (_Cid.getType() != Symbol.TYPE_INTEGER || _C.getType() != Symbol.TYPE_BYTE)) {
                System.err.println(lexical.line + ":tipos incompativeis.");
                System.exit(0);
            } 
            
            // semantic action [C5]
            if (_Cid.getType() == Symbol.TYPE_STRING) {
                String labelS = l.newLabel();
                String labelE = l.newLabel();
                b.add("mov SI, DS:[" + _C.getAddress() + "]; SI contains string a");
                b.add("mov DI, " + _Cid.getAddress() + "; DI contains new string");
                b.add("mov AX, DS:[SI]");

                b.add(labelS + ":");
                b.add("cmp AX, 36");
                b.add("je " + labelE);
                b.add("mov DS:[DI], AX");
                b.add("add SI, 1");
                b.add("add DI, 1");
                b.add("mov AX, DS:[SI]");
                b.add("jmp " + labelS);
                
                b.add(labelE + ":");
                b.add("mov AX, DS:[SI]");
            } else if (_Cid.getType() == Symbol.TYPE_INTEGER) {
                if (_C.getType() == Symbol.TYPE_BYTE) {
                    b.add("mov AL, DS:[" + _C.getAddress() + "]");
                    b.add("cbw");
                } else {
                    b.add("mov AX, DS:[" + _C.getAddress() + "]");
                }
                
                b.add("mov DS:[" + table.searchSymbol(_Cid.getLexeme()).getAddress() + "], AX");
            } else {
                b.add("mov AL, DS:[" + _C.getAddress() + "]");
                b.add("mov DS:[" + table.searchSymbol(_Cid.getLexeme()).getAddress() + "], AL");
            }
            
            matchToken(SymbolTable.SEMICOLON);
        } // C -> WHILE OPPAR E CLPAR (BEGIN {C} ENDWHILE | C)
        else if (s.getToken() == SymbolTable.WHILE) {
            matchToken(SymbolTable.WHILE);
            b.add("");
            b.add(";while");
                
            matchToken(SymbolTable.OPPAR);
            m.resetTemporary();
            E(_C);
            
            // semantic action [T10]
            if (_C.getType() != Symbol.TYPE_LOGICAL) {
                System.err.println(lexical.line + ":tipos incompativeis.");
                System.exit(0);
            }
            
            // semantic action [C6]
            String labelStart = l.newLabel();
            String labelEnd = l.newLabel();
            
            {
                b.add(labelStart + ":");
                b.add("mov AL, DS:[" + _C.getAddress() + "]");
                b.add("cmp AL, 255");
                b.add("jne " + labelEnd);
            }
            
            matchToken(SymbolTable.CLPAR);

            if (s.getToken() == SymbolTable.BEGIN) {
                matchToken(SymbolTable.BEGIN);

                while (s.getToken() == SymbolTable.ID || s.getToken() == SymbolTable.WHILE || s.getToken() == SymbolTable.IF || s.getToken() == SymbolTable.SEMICOLON || s.getToken() == SymbolTable.READLN || s.getToken() == SymbolTable.WRITE || s.getToken() == SymbolTable.WRITELN) {
                    C();
                }

                matchToken(SymbolTable.ENDWHILE);
            } else {
                C();
            }
            
            // semantic action [C7]
            {
                b.add("jmp " + labelStart);
                b.add(labelEnd + ":");
            }
            
        } // C -> IF OPPAR E CLPAR (BEGIN {C} ENDIF [ELSE (BEGIN {C} ENDELSE | C)] | C [ELSE (BEGIN {C} ENDELSE | C)])
        else if (s.getToken() == SymbolTable.IF) {
            matchToken(SymbolTable.IF);
            b.add("");
            b.add(";if");
            
            matchToken(SymbolTable.OPPAR);
            m.resetTemporary();
            E(_C);
            
            // semantic action [T10]
            if (_C.getType() != Symbol.TYPE_LOGICAL) {
                System.err.println(lexical.line + ":tipos incompativeis.");
                System.exit(0);
            }
            
            _Celse = false;
            
            // semantic action [C8]
            String labelFalse = l.newLabel();
            
            {
                b.add("mov AL, DS:[" + _C.getAddress() + "]");
                b.add("cmp AL, 255");
                b.add("jne " + labelFalse);
            }
            
            matchToken(SymbolTable.CLPAR);

            if (s.getToken() == SymbolTable.BEGIN) {
                matchToken(SymbolTable.BEGIN);

                while (s.getToken() == SymbolTable.ID || s.getToken() == SymbolTable.WHILE || s.getToken() == SymbolTable.IF || s.getToken() == SymbolTable.SEMICOLON || s.getToken() == SymbolTable.READLN || s.getToken() == SymbolTable.WRITE || s.getToken() == SymbolTable.WRITELN) {
                    C();
                }

                matchToken(SymbolTable.ENDIF);

                if (s.getToken() == SymbolTable.ELSE) {
                    matchToken(SymbolTable.ELSE);
                    _Celse = true;
                    
                    // semantic action [C9]
                    {
                        b.add(labelFalse + ":");
                    }
                    
                    if (s.getToken() == SymbolTable.BEGIN) {
                        matchToken(SymbolTable.BEGIN);

                        while (s.getToken() == SymbolTable.ID || s.getToken() == SymbolTable.WHILE || s.getToken() == SymbolTable.IF || s.getToken() == SymbolTable.SEMICOLON || s.getToken() == SymbolTable.READLN || s.getToken() == SymbolTable.WRITE || s.getToken() == SymbolTable.WRITELN) {
                            C();
                        }

                        matchToken(SymbolTable.ENDELSE);
                    } else {
                        C();
                    }
                }
            } else {
                C();

                if (s.getToken() == SymbolTable.ELSE) {
                    matchToken(SymbolTable.ELSE);
                    _Celse = true;
                    
                    // semantic action [C9]
                    {
                        b.add(labelFalse + ":");
                    }

                    if (s.getToken() == SymbolTable.BEGIN) {
                        matchToken(SymbolTable.BEGIN);

                        while (s.getToken() == SymbolTable.ID || s.getToken() == SymbolTable.WHILE || s.getToken() == SymbolTable.IF || s.getToken() == SymbolTable.SEMICOLON || s.getToken() == SymbolTable.READLN || s.getToken() == SymbolTable.WRITE || s.getToken() == SymbolTable.WRITELN) {
                            C();
                        }

                        matchToken(SymbolTable.ENDELSE);
                    } else {
                        C();
                    }
                }
            }
            
            // semantic action [C10]
            if (!_Celse) {
                b.add(labelFalse + ":");
            }
        } // C -> SEMICOLON
        else if (s.getToken() == SymbolTable.SEMICOLON) {
            matchToken(SymbolTable.SEMICOLON);
            b.add("");
            b.add(";;");
            
        } // C -> READLN OPPAR ID CLPAR SEMICOLON
        else if (s.getToken() == SymbolTable.READLN) {
            matchToken(SymbolTable.READLN);
            
            b.add("");
            b.add(";readln");
            
            matchToken(SymbolTable.OPPAR);
            _Cid = s;
            matchToken(SymbolTable.ID);
            
            // semantic action [U3]
            if (_Cid.getCategory() == Symbol.NO_CATEGORY) {
                System.err.println(lexical.line + ":identificador nao declarado [" + _Cid.getLexeme() + "].");
                System.exit(0);
            } 
            
            // semantic action [C1]
            if (_Cid.getCategory() != Symbol.CATEGORY_VARIABLE) {
                System.err.println(lexical.line + ":classe de identificador incompativel [" + _Cid.getLexeme() + "].");
                System.exit(0);
            }
            
            // semantic action [T11]
            if (_Cid.getType() == Symbol.TYPE_LOGICAL) {
                System.err.println(lexical.line + ":tipos incompativeis.");
                System.exit(0);
            }
            
            // semantic action [C11]
            {
                String labelR0 = l.newLabel();
                String labelR1 = l.newLabel();
                String labelR2 = l.newLabel();
                int bufferAddress = m.allocateTemporaryBuffer();
                
                b.add("mov DX, " + bufferAddress);
                b.add("mov AL, 255");
                b.add("mov DS:[" + bufferAddress + "], AL");
                b.add("mov AH, 10");
                b.add("int 33");
                b.add("mov AH, 2");
                b.add("mov DL, 13");
                b.add("int 33");
                b.add("mov DL, 10");
                b.add("int 33");
                
                
                b.add("mov DI, " + (bufferAddress + 2) + "          ;posição do string");
                b.add("mov AX, 0    ;acumulador");
                b.add("mov CX, 10   ;base decimal");
                b.add("mov DX, 1    ;valor sinal +");
                b.add("mov BH, 0");
                b.add("mov BL, DS:[DI] ;caractere");
                b.add("cmp BX, 45 ;verifica sinal");
                b.add("jne " + labelR0 + " ;se não negativo");
                b.add("mov DX, -1 ;valor sinal -");
                b.add("add DI, 1 ;incrementa base");
                b.add("mov BL, DS:[DI] ;próximo caractere");
                
                b.add(labelR0 + ":");
                b.add("push DX ;empilha sinal");
                b.add("mov dx, 0 ;reg. multiplicacao");
                
                b.add(labelR1 + ":");
                b.add("cmp BX, 13 ;verifica fim string");
                b.add("je " + labelR2 + " ;salta se fim string");
                b.add("imul CX ;mult. 10");
                b.add("add BX, -48 ;converte caractere");
                b.add("add AX, BX ;soma valor caractere");
                b.add("add DI, 1 ;incrementa base");
                b.add("mov BH, 0");
                b.add("mov BL, DS:[DI] ;próximo caractere");
                b.add("jmp " + labelR1 + " ;loop");
                
                b.add(labelR2 + ":");
                b.add("pop CX ;desempilha sinal");
                b.add("imul CX ;mult. sinal");
                
                b.add("mov DS:[" + table.searchSymbol(_Cid.getLexeme()).getAddress() + "], AX");
            }
            
            matchToken(SymbolTable.CLPAR);
            matchToken(SymbolTable.SEMICOLON);
        } // C -> (WRITE | WRITELN) OPPAR E {COMMA E} CLPAR SEMICOLON
        else {
            if (s.getToken() == SymbolTable.WRITE) {
                matchToken(SymbolTable.WRITE);
                b.add("");
                b.add(";write");
                
                // semantic action [H3]
                _ClineBreak = false;
            } else {
                matchToken(SymbolTable.WRITELN);
                b.add("");
                b.add(";writeln");
                
                // semantic action [H4]
                _ClineBreak = true;
            }

            matchToken(SymbolTable.OPPAR);
            m.resetTemporary();
            E(_C);
            
            // semantic action [T12]
            if (_C.getType() == Symbol.TYPE_LOGICAL) {
                System.err.println(lexical.line + ":tipos incompativeis.");
                System.exit(0);
            }
            
            // semantic action [C12]
            if (_C.getType() == Symbol.TYPE_STRING) {
                b.add("mov DX, " + _C.getAddress());
                b.add("mov AH, 9");
                b.add("int 033");
            } else {
                String labelR0 = l.newLabel();
                String labelR1 = l.newLabel();
                String labelR2 = l.newLabel();
                int stringAddress = m.allocateTemporaryString();
                
                b.add("mov DI, " + stringAddress + " ;end. string temp");
                
                if (_C.getType() == Symbol.TYPE_INTEGER) {
                    b.add("mov AX, DS:[" + _C.getAddress() + "]");
                } else {
                    b.add("mov AL, DS:[" + _C.getAddress() + "]");
                    b.add("cbw");
                }
                
                b.add("mov CX, 0 ;contador");
                b.add("cmp AX,0 ;verifica sinal");
                b.add("jge " + labelR0 + " ;salta se número positivo");
                b.add("mov BL, 45 ;senão, escreve sinal –");
                b.add("mov DS:[DI], BL");
                b.add("add DI, 1 ;incrementa índice");
                b.add("neg AX ;toma módulo do número");
                
                b.add(labelR0 + ":");
                b.add("mov BX, 10 ;divisor");
                
                b.add(labelR1 + ":");
                b.add("add CX, 1 ;incrementa contador");
                b.add("mov DX, 0 ;estende 32bits p/ div.");
                b.add("idiv BX ;divide DXAX por BX");
                b.add("push DX ;empilha valor do resto");
                b.add("cmp AX, 0 ;verifica se quoc. é 0");
                b.add("jne " + labelR1 + " ;se não é 0, continua");
                
                b.add(";agora, desemp. os valores e escreve o string");
                b.add(labelR2 + ":");
                b.add("pop DX ;desempilha valor");
                b.add("add DX, 48 ;transforma em caractere");
                b.add("mov DS:[DI],DL ;escreve caractere");
                b.add("add DI, 1 ;incrementa base");
                b.add("add CX, -1 ;decrementa contador");
                b.add("cmp CX, 0 ;verifica pilha vazia");
                b.add("jne " + labelR2 + " ;se não pilha vazia, loop");
                
                b.add(";grava fim de string");
                b.add("mov DL, 36 ;fim de string");
                b.add("mov DS:[DI], DL ;grava '$'");
                
                b.add(";exibe string");
                b.add("mov DX, " + stringAddress);
                b.add("mov AH, 9");
                b.add("int 33");
                
                if (_ClineBreak) {
                    b.add("mov DX, 13");
                    b.add("mov AH, 2");
                    b.add("int 33");
                    b.add("mov DX, 10");
                    b.add("int 33");
                }
            }
            
            while (s.getToken() == SymbolTable.COMMA) {
                matchToken(SymbolTable.COMMA);
                m.resetTemporary();
                E(_C);
                
                // semantic action [T12]
                if (_C.getType() == Symbol.TYPE_LOGICAL) {
                    System.err.println(lexical.line + ":tipos incompativeis.");
                    System.exit(0);
                }
            }

            matchToken(SymbolTable.CLPAR);
            matchToken(SymbolTable.SEMICOLON);
        }
    }

    /**
     * Procedure that implements the expressions.
     */
    private void E(AuxiliarySymbol _E) {
        AuxiliarySymbol _X1 = new AuxiliarySymbol();
        byte _Eoperator;
        
        // E -> X [(LESSTHAN | MORETHAN | LESSEQUAL | MOREEQUAL | DIFFERENT | EQUALS) X]
        // semantic action [T13]
        // swmantic action [C9']
        X(_E);
        
        // semantic action [H5]
        _Eoperator = 0;

        if (s.getToken() == SymbolTable.LESSTHAN || s.getToken() == SymbolTable.MORETHAN || s.getToken() == SymbolTable.LESSEQUAL || s.getToken() == SymbolTable.MOREEQUAL || s.getToken() == SymbolTable.DIFFERENT || s.getToken() == SymbolTable.EQUALS) {
            // semantic action [H6], [H7], [H8], [H9], [H10], [H11]
            _Eoperator = s.getToken();
            
            matchToken(s.getToken());
            X(_X1);
            
            // semantic action [T14]
            if (_Eoperator != SymbolTable.EQUALS) {
                if (_E.getType() == Symbol.TYPE_LOGICAL || _E.getType() == Symbol.TYPE_STRING || _X1.getType() == Symbol.TYPE_LOGICAL || _X1.getType() == Symbol.TYPE_STRING) {
                    System.err.println(lexical.line + ":tipos incompativeis.");
                    System.exit(0);
                }
            } else {
                if ((_E.getType() == Symbol.TYPE_LOGICAL || _X1.getType() == Symbol.TYPE_LOGICAL || (_E.getType() == Symbol.TYPE_STRING ^ _X1.getType() == Symbol.TYPE_STRING))) {
                    System.err.println(lexical.line + ":tipos incompativeis.");
                    System.exit(0);
                }
            }
            
            // semantic action [C'10']
            {
                String labelEnd = l.newLabel();
                String labelTrue = l.newLabel();
                String labelFalse = l.newLabel();

                if (_E.getType() == Symbol.TYPE_STRING) {
                    String labelS = l.newLabel();            
                    b.add("mov SI, DS:[" + _E.getAddress() + "]; SI contains string a");
                    b.add("mov DI, DS:[" + _X1.getAddress() + "]; SI contains string b");

                    b.add(labelS + ":");
                    b.add("mov AL, DS:[SI]");
                    b.add("mov BL, DS:[DI]");

                    b.add("cmp AX, BX");
                    b.add("jne " + labelEnd);

                    b.add("cmp AX, 36");
                    b.add("je " + labelTrue);

                    b.add("jmp " + labelS);

                } else {
                    if (_E.getType() == Symbol.TYPE_BYTE && _X1.getType() == Symbol.TYPE_BYTE) {
                        b.add("mov AL, DS:[" + _E.getAddress() + "]");
                        b.add("mov BL, DS:[" + _X1.getAddress() + "]");
                        b.add("cmp AL, BL");
                    } else {
                        if (_E.getType() == Symbol.TYPE_BYTE) {
                            b.add("mov AL, DS:[" + _E.getAddress() + "]");
                            b.add("cbw");
                            b.add("mov CX, AX");
                        } else {
                            b.add("mov CX, DS:[" + _E.getAddress() + "]");
                        }

                        if (_X1.getType() == Symbol.TYPE_BYTE) {
                            b.add("mov AL, DS:[" + _X1.getAddress() + "]");
                            b.add("cbw");
                            b.add("mov DX, AX");
                        } else {
                            b.add("mov DX, DS:[" + _X1.getAddress() + "]");
                        }

                        b.add("cmp CX, DX");   
                    }

                    if (_Eoperator == SymbolTable.EQUALS)
                        b.add("je " + labelTrue);
                    else if (_Eoperator == SymbolTable.DIFFERENT)
                        b.add("jne " + labelTrue);
                    else if (_Eoperator == SymbolTable.LESSTHAN)
                        b.add("jl " + labelTrue);
                    else if (_Eoperator == SymbolTable.LESSEQUAL)
                        b.add("jle " + labelTrue);
                    else if (_Eoperator == SymbolTable.MORETHAN)
                        b.add("jg " + labelTrue);
                    else
                        b.add("jge " + labelTrue);
                }

                b.add(labelFalse + ":");
                b.add("mov AL, 0");
                b.add("jmp " + labelEnd);

                b.add(labelTrue + ":");
                b.add("mov AL, 255");

                b.add(labelEnd + ":");
                _E.setAddress(m.allocateTemporaryLogical());
                b.add("mov DS:[" + _E.getAddress() + "], AL");
            }
            
            _E.setType(Symbol.TYPE_LOGICAL);
        }
        
        
    }

    /**
     * Procedure that implements the simple expressions.
     */
    private void X(AuxiliarySymbol _X) {
        AuxiliarySymbol _T1 = new AuxiliarySymbol();
        boolean _Xoption, _Xminus = false, _Xplus, _Xlogical;
        
        // semantic action [H12]
        _Xoption = false;
        
        // X -> [PLUS | MINUS] T {(PLUS | MINUS | OR) T}
        if (s.getToken() == SymbolTable.PLUS || s.getToken() == SymbolTable.MINUS) {
            // semantic action [H13]
            _Xoption = true;
            
            // semantic action [H14]
            if (s.getToken() == SymbolTable.PLUS) {
                _Xminus = false;
            }
            // semantic action [H15]
            else {
                _Xminus = true;
            }
            matchToken(s.getToken());
        }
        
        // semantic action [T15]
        T(_X);
        
        // semantic action [T16]
        if (_Xoption && (_X.getType() == Symbol.TYPE_STRING || _X.getType() == Symbol.TYPE_LOGICAL)) {
            System.err.println(lexical.line + ":tipos incompativeis.");
            System.exit(0);
        }
        
        // semantic action [C7']
        if (_Xminus) {
            b.add("mov AX, DS:[" + _X.getAddress() + "]");
            _X.setAddress(m.allocateTemporaryInteger());
            b.add("neg AX");
            b.add("mov DS:[" + _X.getAddress() + "], AX");
        }

        while (s.getToken() == SymbolTable.PLUS || s.getToken() == SymbolTable.MINUS || s.getToken() == SymbolTable.OR) {
            // semantic action [H17]
            if (s.getToken() == SymbolTable.OR) {
                _Xlogical = true;
                _Xplus = false;
            }
            // semantic actino [H16] 
            else {
                _Xlogical = false;
                
                // semantic action [H18]
                if (s.getToken() == SymbolTable.PLUS) {
                    _Xplus = true;
                }
                // semantic action [H19]
                else {
                    _Xplus = false;
                }
            }
            matchToken(s.getToken());
            T(_T1);
            
            // semantic action [T17]
            if (_Xlogical) {
                if (_X.getType() != Symbol.TYPE_LOGICAL || _T1.getType()!= Symbol.TYPE_LOGICAL) {
                    System.err.println(lexical.line + ":tipos incompativeis.");
                    System.exit(0);
                }
            } else {
                if (!_Xplus) {
                    if (_X.getType() == Symbol.TYPE_LOGICAL || _X.getType() == Symbol.TYPE_STRING || _T1.getType() == Symbol.TYPE_LOGICAL || _T1.getType() == Symbol.TYPE_STRING) {
                        System.err.println(lexical.line + ":tipos incompativeis.");
                    System.exit(0);
                    } else if (_X.getType() != _T1.getType()){
                        _X.setType(Symbol.TYPE_INTEGER);
                    }
                } else {
                    if ((_X.getType() == Symbol.TYPE_LOGICAL || _X.getType() == Symbol.TYPE_STRING || _T1.getType() == Symbol.TYPE_LOGICAL || _T1.getType() == Symbol.TYPE_STRING) && (_X.getType() != Symbol.TYPE_STRING && _T1.getType() != Symbol.TYPE_STRING)) {
                        System.err.println(lexical.line + ":tipos incompativeis.");
                    System.exit(0);
                    } else if (_X.getType() != _T1.getType()){
                        _X.setType(Symbol.TYPE_INTEGER);
                    }
                }
            }
            
            // semantic action [C8']
            if (_Xlogical) {        // OR
                b.add("mov AL, DS:[" + _X.getAddress() + "]");
                b.add("mov BL, DS:[" + _T1.getAddress() + "]");
                b.add("or AL, BL");
                _X.setAddress(m.allocateTemporaryLogical());
                b.add("mov DS:[" + _X.getAddress() + "], AL");
            } else if (_Xplus) {    // PLUS
                if (_X.getType() == Symbol.TYPE_STRING) {
                    String labelA = l.newLabel();
                    String labelAB = l.newLabel();
                    String labelB = l.newLabel();
                    String labelE = l.newLabel();
                    
                    b.add("mov SI, DS:[" + _X.getAddress() + "]; SI contains string a");
                    _X.setAddress(m.allocateTemporaryLogical());
                    b.add("mov DI, " + _X.getAddress() + "; DI contains new string");
                    b.add("mov AX, DS:[SI]");
                    
                    b.add(labelA + ":");
                    b.add("cmp AX, 36");
                    b.add("je " + labelAB);
                    b.add("mov DS:[DI], AX");
                    b.add("add SI, 1");
                    b.add("add DI, 1");
                    b.add("mov AX, DS:[SI]");
                    b.add("jmp " + labelA);
                    
                    b.add(labelAB + ":");
                    b.add("mov SI, DS:[" + _T1.getAddress() + "]; SI contains string b");
                    b.add("mov AX, DS:[SI]");
                    
                    b.add(labelB + ":");
                    b.add("cmp AX, 36");
                    b.add("je " + labelE);
                    b.add("mov DS:[DI], AX");
                    b.add("add SI, 1");
                    b.add("add DI, 1");
                    b.add("mov AX, DS:[SI]");
                    b.add("jmp " + labelB);
                    
                    b.add(labelE + ":");
                    b.add("mov DS:[DI], AX");
                } else {
                    if (_X.getType() == Symbol.TYPE_BYTE && _T1.getType() == Symbol.TYPE_BYTE) {
                        b.add("mov AL, DS:[" + _X.getAddress() + "]");
                        b.add("mov BL, DS:[" + _T1.getAddress() + "]");
                        b.add("add AL, BL");
                        _X.setAddress(m.allocateTemporaryByte());
                        b.add("mov DS:[" + _X.getAddress() + "], AL");
                    } else {
                        if (_X.getType() == Symbol.TYPE_BYTE) {
                            b.add("mov AL, DS:[" + _X.getAddress() + "]");
                            b.add("cbw");
                            b.add("mov CX, AX");
                        } else {
                            b.add("mov CX, DS:[" + _X.getAddress() + "]");
                        }

                        if (_T1.getType() == Symbol.TYPE_BYTE) {
                            b.add("mov AL, DS:[" + _T1.getAddress() + "]");
                            b.add("cbw");
                            b.add("mov DX, AX");
                        } else {
                            b.add("mov DX, DS:[" + _T1.getAddress() + "]");
                        }

                        b.add("add CX, DX");
                        _X.setAddress(m.allocateTemporaryInteger());
                        b.add("mov DS:[" + _X.getAddress() + "], CX");
                    }
                }
            } else {                // MINUS
                if (_X.getType() == Symbol.TYPE_BYTE && _T1.getType() == Symbol.TYPE_BYTE) {
                    b.add("mov AL, DS:[" + _X.getAddress() + "]");
                    b.add("mov BL, DS:[" + _T1.getAddress() + "]");
                    b.add("sub AL, BL");
                    _X.setAddress(m.allocateTemporaryByte());
                    b.add("mov DS:[" + _X.getAddress() + "], AL");
                } else {
                    if (_X.getType() == Symbol.TYPE_BYTE) {
                        b.add("mov AL, DS:[" + _X.getAddress() + "]");
                        b.add("cbw");
                        b.add("mov CX, AX");
                    } else {
                        b.add("mov CX, DS:[" + _X.getAddress() + "]");
                    }
                    
                    if (_T1.getType() == Symbol.TYPE_BYTE) {
                        b.add("mov AL, DS:[" + _T1.getAddress() + "]");
                        b.add("cbw");
                        b.add("mov DX, AX");
                    } else {
                        b.add("mov DX, DS:[" + _T1.getAddress() + "]");
                    }
                    
                    b.add("sub CX, DX");
                    _X.setAddress(m.allocateTemporaryInteger());
                    b.add("mov DS:[" + _X.getAddress() + "], CX");
                }
            }
        }
    }

    /**
     * Procedure that implements the terms.
     */
    private void T(AuxiliarySymbol _T) {
        AuxiliarySymbol _F1 = new AuxiliarySymbol();
        boolean _Tlogical, _Ttimes;
        
        // T -> F {(TIMES | DIVIDE | AND) F}        
        // semantic action [T18]
        // semantic action [C5']
        F(_T);

        while (s.getToken() == SymbolTable.TIMES || s.getToken() == SymbolTable.DIVIDE || s.getToken() == SymbolTable.AND) {
            // semantic action [H21]
            if (s.getToken() == SymbolTable.AND) {
                _Tlogical = true;
                _Ttimes = false;
            }
            // semantic action [H20]
            else {
                _Tlogical = false;
                
                // semantic action [H22]
                if (s.getToken() == SymbolTable.TIMES) {
                    _Ttimes = true;
                }
                // semantic action [H23]
                else {
                    _Ttimes = false;
                }
            }
            matchToken(s.getToken());
            F(_F1);
            
            // semantic action [T19]
            if (_Tlogical) {
                if (_T.getType() != Symbol.TYPE_LOGICAL || _F1.getType() != Symbol.TYPE_LOGICAL) {
                    System.err.println(lexical.line + ":tipos incompativeis.");
                    System.exit(0);
                }
            } else {
                if (_T.getType() == Symbol.TYPE_LOGICAL ||_T.getType() == Symbol.TYPE_STRING || _F1.getType() == Symbol.TYPE_LOGICAL || _F1.getType() == Symbol.TYPE_STRING) {
                    System.err.println(lexical.line + ":tipos incompativeis.");
                    System.exit(0);
                } else if (_T.getType() != _F1.getType()) {
                    _T.setType(Symbol.TYPE_INTEGER);
                }
            }
            
            // semantic action [C6']
            if (_Tlogical) {        // AND
                b.add("mov AL, DS:[" + _T.getAddress() + "]");
                b.add("mov BL, DS:[" + _F1.getAddress() + "]");
                b.add("and AL, BL");
                _T.setAddress(m.allocateTemporaryLogical());
                b.add("mov DS:[" + _T.getAddress() + "], AL");
            } else if (_Ttimes) {   // TIMES
                if (_T.getType() == Symbol.TYPE_BYTE && _F1.getType() == Symbol.TYPE_BYTE) {
                    b.add("mov AL, DS:[" + _T.getAddress() + "]");
                    b.add("mov BL, DS:[" + _F1.getAddress() + "]");
                    b.add("mul BL");
                    _T.setAddress(m.allocateTemporaryByte());
                    b.add("mov DS:[" + _T.getAddress() + "], AL");
                } else {
                    if (_T.getType() == Symbol.TYPE_BYTE) {
                        b.add("mov AL, DS:[" + _T.getAddress() + "]");
                        b.add("cbw");
                        b.add("mov CX, AX");
                    } else {
                        b.add("mov CX, DS:[" + _T.getAddress() + "]");
                    }
                    
                    if (_F1.getType() == Symbol.TYPE_BYTE) {
                        b.add("mov AL, DS:[" + _F1.getAddress() + "]");
                        b.add("cbw");
                        b.add("mov DX, AX");
                    } else {
                        b.add("mov DX, DS:[" + _F1.getAddress() + "]");
                    }
                    
                    b.add("mov AX, CX");
                    b.add("imul DX");
                    _T.setAddress(m.allocateTemporaryInteger());
                    b.add("mov DS:[" + _T.getAddress() + "], AX");
                }        
            } else {                // DIVIDE
                if (_T.getType() == Symbol.TYPE_BYTE) {
                    b.add("mov AL, DS:[" + _T.getAddress() + "]");
                    b.add("cbw");
                    b.add("mov CX, AX");
                } else {
                    b.add("mov CX, DS:[" + _T.getAddress() + "]");
                }
                
                if (_F1.getType() == Symbol.TYPE_BYTE) {
                    b.add("mov AL, DS:[" + _F1.getAddress() + "]");
                    b.add("cbw");
                    b.add("mov DX, AX");
                } else {
                    b.add("mov DX, DS:[" + _F1.getAddress() + "]");
                }
                
                b.add("mov AX, CX");
                b.add("cwd");
                b.add("idiv DX");
                
                _T.setAddress(m.allocateTemporaryInteger());
                b.add("mov DS:[" + _T.getAddress() + "], AX");
            }
        }
    }

    /**
     * Procedure that implements the factors.
     */
    private void F(AuxiliarySymbol _F) {
        AuxiliarySymbol _F1 = new AuxiliarySymbol();
        Symbol _Fid, _Fconst;
        
        // F -> OPPAR E CLPAR
        if (s.getToken() == SymbolTable.OPPAR) {
            matchToken(SymbolTable.OPPAR);
            
            // semantic action [T20]
            // semantic action [C3']
            E(_F);
            
            matchToken(SymbolTable.CLPAR);
        } // F -> ID
        else if (s.getToken() == SymbolTable.ID) {
            _Fid = s;
            matchToken(SymbolTable.ID);
            
            // semantic action [U3]
            if (_Fid.getCategory() == Symbol.NO_CATEGORY) {
                System.err.println(lexical.line + ":identificador nao declarado [" + _Fid.getLexeme() + "].");
                System.exit(0);
            } 
            
            // semantic action [T21]
            _F.setType(table.searchSymbol(_Fid.getLexeme()).getType());
            
            // semantic action [C1']
            _F.setAddress(table.searchSymbol(_Fid.getLexeme()).getAddress());
        } // F -> CONST
        else if (s.getToken() == SymbolTable.CONST) {
            _Fconst = s;
            matchToken(SymbolTable.CONST);
            
            // semantic action [T22]
            _F.setType(_Fconst.getType());
            
            // semantic action [C2']
            if (_Fconst.getType() == Symbol.TYPE_STRING) {
                b.add("dseg SEGMENT PUBLIC");
                b.add("byte \"" + _Fconst.getLexeme() + "\" ;var. string");
                b.add("dseg ENDS");
                _F.setAddress(m.allocateString(_Fconst.getLexeme().length()));
            } else {
                if (_Fconst.getType() == Symbol.TYPE_INTEGER) {
                    _F.setAddress(m.allocateTemporaryInteger());
                    b.add("mov AX, " + _Fconst.getLexeme());
                    b.add("mov DS:[" + _F.getAddress() + "], AX");
                } else if (_Fconst.getType() == Symbol.TYPE_BYTE) {
                    _F.setAddress(m.allocateTemporaryByte());
                    b.add("mov AL, " + _Fconst.getLexeme());
                    b.add("mov DS:[" + _F.getAddress() + "], AL");
                } else {
                    _F.setAddress(m.allocateTemporaryLogical());
                    
                    if (_Fconst.getLexeme().equals("TRUE")) {
                        b.add("mov AL, 255");
                    } else {
                        b.add("mov AL, 0");
                    }
                    
                    b.add("mov DS:[" + _F.getAddress() + "], AL");
                }
            }
        } // F -> NOT F
        else {
            matchToken(SymbolTable.NOT);
            F(_F1);
            
            // semantic action [T23]
            if (_F1.getType() != Symbol.TYPE_LOGICAL) {
                System.err.println(lexical.line + ":tipos incompativeis.");
                System.exit(0);
            } else {
                _F.setType(Symbol.TYPE_LOGICAL);
            }
            
            // semantic action [C4']
            _F.setAddress(m.allocateTemporaryLogical());
            b.add("mov AL, DS:[" + _F1.getAddress() + "]");
            b.add("not AL");
            b.add("DS:[" + _F.getAddress() + "], AL");
        }
    }

    /**
     * Compares if the received token equals to the expected. If so, it calls
     * the lexical analyzer and reads the next token; otherwise, it will stop
     * the execution with an error
     *
     * @param token expected token
     */
    private void matchToken(byte token) {
        try {
            if (!lexical.EOF) {
                if (s.getToken() == token) {
                    s = lexical.getNextLexeme(file);
                } else if (s == null) {
                    System.err.println(lexical.line + ":fim de arquivo nao esperado.");
                    System.exit(0);
                } else {
                    System.err.println(lexical.line + ":token nao esperado [" + s.getLexeme() + "].");
                    System.exit(0);
                }
            }
        } catch (Exception e) {
            System.err.println("matchToken: " + e.getMessage());
        }
    }

}
