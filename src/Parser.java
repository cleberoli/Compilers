/*
* Pontifical Catholic University of Minas Gerais
* Institue of Exact Sciences and Technology
* Compilers
*
* Authors: Cleber Oliveira, Karen Martins, and Sarah Almeida
* IDs: 486564, 476140, 476181
 */

import java.io.BufferedReader;

/**
 * Processes the tokens generated by the lexical analyzer in order to verify if
 * the source program is generated by the grammar
 */
public class Parser {

    BufferedReader file;
    LexicalAnalyzer lexical;
    SymbolTable table;
    Symbol s;

    /**
     * Default constructor, it initializes the variables that will be used
     * during its execution, creates the instance of the SymbolTable and
     * LexicalAnalyzer
     *
     * @param source BufferedReader containing the information of the source
     * file.
     */
    public Parser(BufferedReader source) {
        try {
            file = source;
            table = new SymbolTable();
            lexical = new LexicalAnalyzer(table);
            s = lexical.getNextLexeme(file);
        } catch (Exception e) {
            System.err.println(e.getMessage());
        }
    }

    /**
     * Procedure that implements the initial symbol of the grammar.
     */
    public void S() {
        // S -> {D}
        while (s.getToken() == table.INT || s.getToken() == table.BOOLEAN || s.getToken() == table.BYTE || s.getToken() == table.STRING || s.getToken() == table.FINAL) {
            D();
        }

        if (s.getToken() == table.EOF) {
            System.err.println(lexical.line + ":fim de arquivo nao esperado.");
            System.exit(0);
        }

        // S -> {C}+
        do {
            C();
        } while (s.getToken() == table.ID || s.getToken() == table.WHILE || s.getToken() == table.IF || s.getToken() == table.SEMICOLON || s.getToken() == table.READLN || s.getToken() == table.WRITE || s.getToken() == table.WRITELN);
        if (!lexical.EOF) {
            System.err.println(lexical.line + ":token nao esperado [" + s.getLexeme() + "].");
            System.exit(0);
        }
    }

    /**
     * Procedure that implements the declarations.
     */
    private void D() {
        // D -> (INT|BOOLEAN|BYTE|STRING) ID [RECEIVE [MINUS] CONST] {COMMA ID [RECEIVE [MINUS] CONST]} SEMICOLON
        if (s.getToken() == table.INT || s.getToken() == table.BOOLEAN || s.getToken() == table.BYTE || s.getToken() == table.STRING) {
            matchToken(s.getToken());
            matchToken(table.ID);

            if (s.getToken() == table.RECEIVE) {
                matchToken(table.RECEIVE);

                if (s.getToken() == table.MINUS) {
                    matchToken(table.MINUS);
                }

                matchToken(table.CONST);
            }

            while (s.getToken() == table.COMMA) {
                matchToken(table.COMMA);
                matchToken(table.ID);

                if (s.getToken() == table.RECEIVE) {
                    matchToken(table.RECEIVE);

                    if (s.getToken() == table.MINUS) {
                        matchToken(table.MINUS);
                    }

                    matchToken(table.CONST);
                }
            }

            matchToken(table.SEMICOLON);
        } // D -> FINAL ID RECEIVE [MINUS] CONST SEMICOLON
        else {
            matchToken(table.FINAL);
            matchToken(table.ID);
            matchToken(table.RECEIVE);

            if (s.getToken() == table.MINUS) {
                matchToken(table.MINUS);
            }

            matchToken(table.CONST);
            matchToken(table.SEMICOLON);
        }
    }

    /**
     * Procedure that implements the commands.
     */
    private void C() {
        // C -> ID RECEIVE E SEMICOLON
        if (s.getToken() == table.ID) {
            matchToken(table.ID);
            matchToken(table.RECEIVE);
            E();
            matchToken(table.SEMICOLON);
        } // C -> WHILE OPPAR E CLPAR (BEGIN {C} ENDWHILE | C)
        else if (s.getToken() == table.WHILE) {
            matchToken(table.WHILE);
            matchToken(table.OPPAR);
            E();
            matchToken(table.CLPAR);

            if (s.getToken() == table.BEGIN) {
                matchToken(table.BEGIN);

                while (s.getToken() == table.ID || s.getToken() == table.WHILE || s.getToken() == table.IF || s.getToken() == table.SEMICOLON || s.getToken() == table.READLN || s.getToken() == table.WRITE || s.getToken() == table.WRITELN) {
                    C();
                }

                matchToken(table.ENDWHILE);
            } else {
                C();
            }
        } // C -> IF OPPAR E CLPAR (BEGIN {C} ENDIF [ELSE (BEGIN {C} ENDELSE | C)] | C [ELSE (BEGIN {C} ENDELSE | C)])
        else if (s.getToken() == table.IF) {
            matchToken(table.IF);
            matchToken(table.OPPAR);
            E();
            matchToken(table.CLPAR);

            if (s.getToken() == table.BEGIN) {
                matchToken(table.BEGIN);

                while (s.getToken() == table.ID || s.getToken() == table.WHILE || s.getToken() == table.IF || s.getToken() == table.SEMICOLON || s.getToken() == table.READLN || s.getToken() == table.WRITE || s.getToken() == table.WRITELN) {
                    C();
                }

                matchToken(table.ENDIF);

                if (s.getToken() == table.ELSE) {
                    matchToken(table.ELSE);

                    if (s.getToken() == table.BEGIN) {
                        matchToken(table.BEGIN);

                        while (s.getToken() == table.ID || s.getToken() == table.WHILE || s.getToken() == table.IF || s.getToken() == table.SEMICOLON || s.getToken() == table.READLN || s.getToken() == table.WRITE || s.getToken() == table.WRITELN) {
                            C();
                        }

                        matchToken(table.ENDELSE);
                    } else {
                        C();
                    }
                }
            } else {
                C();

                if (s.getToken() == table.ELSE) {
                    matchToken(table.ELSE);

                    if (s.getToken() == table.BEGIN) {
                        matchToken(table.BEGIN);

                        while (s.getToken() == table.ID || s.getToken() == table.WHILE || s.getToken() == table.IF || s.getToken() == table.SEMICOLON || s.getToken() == table.READLN || s.getToken() == table.WRITE || s.getToken() == table.WRITELN) {
                            C();
                        }

                        matchToken(table.ENDELSE);
                    } else {
                        C();
                    }
                }
            }
        } // C -> SEMICOLON
        else if (s.getToken() == table.SEMICOLON) {
            matchToken(table.SEMICOLON);
        } // C -> READLN OPPAR ID CLPAR SEMICOLON
        else if (s.getToken() == table.READLN) {
            matchToken(table.READLN);
            matchToken(table.OPPAR);
            matchToken(table.ID);
            matchToken(table.CLPAR);
            matchToken(table.SEMICOLON);
        } // C -> (WRITE | WRITELN) OPPAR E {COMMA E} CLPAR SEMICOLON
        else {
            if (s.getToken() == table.WRITE) {
                matchToken(table.WRITE);
            } else {
                matchToken(table.WRITELN);
            }

            matchToken(table.OPPAR);
            E();
            while (s.getToken() == table.COMMA) {
                matchToken(table.COMMA);
                E();
            }

            matchToken(table.CLPAR);
            matchToken(table.SEMICOLON);
        }
    }

    /**
     * Procedure that implements the expressions.
     */
    private void E() {
        // E -> X [(LESSTHAN | MORETHAN | LESSEQUAL | MOREEQUAL | DIFFERENT | EQUALS) X]
        X();

        if (s.getToken() == table.LESSTHAN || s.getToken() == table.MORETHAN || s.getToken() == table.LESSEQUAL || s.getToken() == table.MOREEQUAL || s.getToken() == table.DIFFERENT || s.getToken() == table.EQUALS) {
            matchToken(s.getToken());
            X();
        }
    }

    /**
     * Procedure that implements the simple expressions.
     */
    private void X() {
        // X -> [PLUS | MINUS] T {(PLUS | MINUS | OR) T}
        if (s.getToken() == table.PLUS || s.getToken() == table.MINUS) {
            matchToken(s.getToken());
        }

        T();

        while (s.getToken() == table.PLUS || s.getToken() == table.MINUS || s.getToken() == table.OR) {
            matchToken(s.getToken());
            T();
        }
    }

    /**
     * Procedure that implements the terms.
     */
    private void T() {
        // T -> F {(TIMES | DIVIDE | AND) F}
        F();

        while (s.getToken() == table.TIMES || s.getToken() == table.DIVIDE || s.getToken() == table.AND) {
            matchToken(s.getToken());
            F();
        }
    }

    /**
     * Procedure that implements the factors.
     */
    private void F() {
        // F -> OPPAR E CLPAR
        if (s.getToken() == table.OPPAR) {
            matchToken(table.OPPAR);
            E();
            matchToken(table.CLPAR);
        } // F -> ID
        else if (s.getToken() == table.ID) {
            matchToken(table.ID);
        } // F -> CONST
        else if (s.getToken() == table.CONST) {
            matchToken(table.CONST);
        } // F -> NOT F
        else {
            matchToken(table.NOT);
            F();
        }
    }

    /**
     * Compares if the received token equals to the expected. If so, it calls
     * the lexical analyzer and reads the next token; otherwise, it will stop
     * the execution with an error
     *
     * @param token expected token
     */
    private void matchToken(byte token) {
        try {
            if (!lexical.EOF) {
                if (s.getToken() == token) {
                    s = lexical.getNextLexeme(file);
                } else if (s == null) {
                    System.err.println(lexical.line + ":fim de arquivo nao esperado.");
                    System.exit(0);
                } else {
                    System.err.println(lexical.line + ":token nao esperado [" + s.getLexeme() + "].");
                    System.exit(0);
                }
            }
        } catch (Exception e) {
            System.err.println("matchToken: " + e.getMessage());
        }
    }

}
